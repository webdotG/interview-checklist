Event Loop & JavaScript 
Погружение в Асинхронное Выполнение и Многопоточность

Определение и роль Event Loop в асинхронном выполнении кода

Event Loop (цикл событий) - это "механизм", который позволяет JS выполнять асинхронные операции без блокировки основного потока. 
Он работает как "регулеровщик", который управляет очередью задач, собирает и обрабатыввет события, передаёт колбэки в стек вызовов, когда тот свободен. Его работа гарантирует, что приложение остается отзывчивым, даже при обработке длительных и/или ресурсотребуемых операций.
Помимо выполнения самого кода JS, Event Loop координирует множество других процессов в среде выполнения. Включая в себя операции ввода/вывода (события мыши и клавиатуры), чтение и запись файлов, а также сетевые операции и рендеринг UI интерфейса. Отсюда следует, что Event Loop не просто управлеет выполнением JS кода,  а есть значимая и неотъемлемая часть всей хост-среды.

Значимость официальных спецификаций (ECMAS, WHATWG) как первоисточников.

Обращаю внимание, что термина "Event Loop" нет в спецификации ECMA-262, а ведь только она (какая бы не была) является источниеом определения JS. 
Но зато это понятие появляется в других источниках, а именно "HOST executor" - среды выполнения JS. 
Для веб-браузеров Event Loop описан в стандарте HTML (WHATWG), вот ссылка. "https://html.spec.whatwg.org/multipage/webappapis.html#event-loops"
А для Node.js это описание есть по этой ссылке. "https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick"

Спека ECMA-262 регулирует процесс выполнения кода через "агентов" (agents) и "очередей задач" (job queues), которые в терминологии и в повседневной практике часто ошибочно проинимают за Event Loop. 
ECMA-262 не концентрирует это регулирование под единым/общим понятием Event Loop, но устанавливает ограничения на реализацию агентов, как например предписание на поведение, что "Если несколько агентов находятся в одном потоке, только один из них должен прогрессировать в любой момент времени"(https://262.ecma-international.org/13.0/#sec-agents)
(есть моменты когда и это можно поправить я сейчас о Web Workers но об этом позже)
Для небраузерных сред - (рассмотрю только) Node.js. Официальным источником о Event Loop является собственная документация. Например, Node.js использует библиотеку "libuv" (https://docs.libuv.org/en/v1.x/design.html#the-i-o-loop) для реализации своей асинхронной, событийно-ориентированной модели ввода/вывода.

Разница между тем, что определяется языком JS и тем, что предоставляется средой выполнения, является базой для понимания параллелизма в JavaScript. 
JS сам по себе не определяет модель потоков. Вместо него это определяет, хост-среда, именно она даёт механизмы для асинхронных операций и многопоточности. 
Такое архитектурное решение позволяет JS быть высокопортируемым языком, так как разлные среды могут адаптировать свои реализации Event Loop, держасб рот этом юазовых правил и понятий языка. Это также объясняет, почему Event Loop в браузере и Node.js, хотя и имеют схожие высокоуровневые концепции, различаются в своих низкоуровневых фазах и приоритетах (например process.nextTick в Node.js механизм, который выполняется перед другими фазами Event Loop в отличие от браузерного queueMicrotask()) https://nodejs.org/docs/latest/api/process.html#processnexttickcallback-args

Развенчание Мифа: JavaScript и Многопоточность

Распространенное представление о JS как о "строго однопоточном" является не совсем точным. 
Хотя сам движок JS (V8), который интерпретирует и компилирует код, действительно работает в одном потоке, обрабатывая один оператор/один операциональный контекст за раз. 
(тут говорится о однопоточности выполнения JS V8 "https://v8.dev/blog/ignition-interpreter")
(оф топ, если хочется посмотреть на работу JS без участия хоз-среды, то сделать это можно в консоли D8 "https://v8.dev/docs/d8")
Более широкая среда выполнения JS (не важно браузер или Node.js "про многопотость ноды"https://nodejs.org/api/worker_threads.html) является многопоточной. 
Эта среда делегирует выполнение асинхронных операций, таких как ввод/вывод, таймеры и сетевые запросы, отдельным потокам или непосредственно операционной системе, тем самым предотвращая блокировку основного потока JS.
Понятие JS как "строго однопоточного" в главной мере своей проистекает (как мне кажется) из принципа однопоточной работы Event Loop, который последовательно обрабатывает асинхронные задачи, рендеринг пользовательского интерфейса и взаимодействия с пользователем. 

Однако, неоходимо различать: конкурентность и параллелизм (ссылка тут "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model#concurrency_vs_parallelism"). 

Конкурентность относится к способности системы управлять несколькими задачами, создавая иллюзию их одновременного выполнения путем быстрого переключения между ними (что и делает Event Loop на одном потоке). 
Параллелизм, напротив, подразумевает истинное одновременное выполнение различных частей программы на нескольких ядрах процессора. 

Event Loop, управляя асинхронными задачами в одном основном потоке, обеспечивает конкурентность.
