5. Агенты и кластеры
Архитектура параллелизма в JS

Про них возможно стоило написать раньше 
(ибо понятия эти ни раз проскакивали), но как структурировал так структурировал.

5.1 Агент

В ECMA "агент" (agent) (https://tc39.es/ecma262/#sec-agents) определяется как автономный исполнитель JS кода (). 

Каждый агент поддерживает свой собственный набор средств для выполнения кода:
- Кучу объектов (Heap): MDN (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_management)  
Это область памяти, где создаются объекты. Изолированное пространство (кроме SharedArrayBuffer).
В случае общей памяти каждый агент имеет свою собственную кучу, но базовая память, представленная объектом SharedArrayBuffer, является общей.   
- Очередь задач (Queue of jobs):
Этот термин используется в спецификации ECMA. 
В терминологии HTML и в повседневной практике эта очередь широко известна как  Event Loop, обрабатываются в порядке FIFO (First-In, First-Out). 
- Стек контекстов выполнения (Stack of execution contexts):
Этот термин используется в спецификации ECMA
В сообществе он более известен как стек вызовов (Call Stack), работает по принципу LIFO (Last-In, First-Out)

-5.1.1 Типы агентов в веб-среде (согласно HTML Standard)

WHATWG (https://html.spec.whatwg.org/multipage/webappapis.html#agents) определяет конкретные типы агентов:
- Агент окна: - Основной поток (Window Agent)
- Агенты Web Workers: включают Dedicated Workers (выделенные воркеры), Shared Workers (общие воркеры) и Service Workers (сервис-воркеры). Каждый из них работает в отдельном потоке
- Агенты Worklets: Специализированные агенты, используемые для низкоуровневой обработки графики или аудио (AudioWorklet, PaintWorklet)

От сюда понимаем:
- Внутри агента: JS однопоточен (один Event Loop)
- Между агентами: Настоящий параллелизм (многопоточность)

5.2 Взаимосвязь агентов с Event Loop (HTML)

В HTML-спецификации, каждый агент имеет свой собственный Event Loop. 
Это означает, что выделенные воркеры и ворклеты, которые имеют флаг can-block установленный в true, работают в своих собственных выделенных потоках, каждый со своим Event Loop.   

ECMA устанавливает ограничения на реализацию агентов: 
Если в одном потоке находится несколько агентов, только один из них должен прогрессировать. 
Это подчеркивает, что Event Loop, хотя и является частью многопоточной среды, обеспечивает, чтобы JS код в рамках одного агента выполнялся последовательно.

Последствия:
- Workers не блокируют главный поток, но их задачи могут "голодать" (starvation), если Event Loop перегружен
Пример: 
Service Worker, обрабатывающий fetch-запросы, работает в отдельном Event Loop. Однако, если собственный Event Loop Service Worker'а (например, из-за слишком большого количества или очень длительных fetch-запросов, которые он перехватывает и обрабатывает ) окажется перегружен, то другие задачи, ожидающие выполнения внутри этого Service Worker'а, могут начать "голодать", то есть их выполнение будет сильно задерживаться или даже не произойдет вовсе. 

5.3 "Кластер агентов" (agent cluster)

ECMA- определяет кластер агентов (https://tc39.es/ecma262/#sec-agent-clusters)  как максимальный набор агентов, которые могут использовать SharedArrayBuffer для совместного доступа к памяти.

WHATWG (https://html.spec.whatwg.org/multipage/webappapis.html#agent-clusters) - расширяет это понятие, добавляя практические правила создания кластеров.
Это группа агентов, которые могут обмениваться информацией путем совместного использования памяти, в основном через объекты SharedArrayBuffer. 
Агенты в одном кластере могут совместно использовать память, в то время как разные кластеры полностью изолированы друг от друга, не имея встроенного механизма для обмена информацией напрямую (только через postMessage).

5.3.1 Правила создания кластера (HTML)

HTML-спецификация устанавливает конкретные требования:
- Агенты одного origin
- Наличие SharedArrayBuffer (требует заголовков COOP/COEP (https://html.spec.whatwg.org/multipage/browsers.html#coop))

Типы агентов, которые могут быть частью кластера согласно HTML: 
- агент окна того же происхождения (Similar-origin window agent)
- агент выделенного воркера (Dedicated worker agent)
- агент общего воркера (Shared worker agent) 
- агент сервис-воркера (Service worker agent)
- агент ворклета (Worklet agent)

5.4  Понимание многопоточности в JS (ещё раз)

Разграничение ECMA и HTML подходов
Понимание "агентов" и "кластеров агентов" позволяет уточнить понятия "однопоточность" и "многопоточность" в контексте JS.

ECMA фокусируется на абстрактной модели выполнения JS-кода.
HTML-спецификация определяет, как эта модель реализуется в браузерной среде.

Однопоточная природа JS относится к выполнению кода внутри одного агента. 
То есть, в рамках одного агента JS выполняет один оператор за раз. 

Однако среда выполнения (браузерная) может создавать множество агентов (агент основного потока, агенты Web Worker), и эти агенты могут работать параллельно. 
Каждый из этих агентов имеет свой собственный Event Loop. 

Таким образом: JS является однопоточным на агент, но многопоточным между агентами. 
Это также объясняет необходимость SharedArrayBuffer и Atomics для управления общим состоянием, поскольку прямой доступ к переменным между агентами не является синхронизированным по умолчанию.

5.5 Следствия и Применение

Безопасность (HTML)
- Изоляция кучи защищает от уязвимостей (Spectre (https://cacm.acm.org/research/spectre-attacks/))
- postMessage и Structured Clone - единственные легальные пути коммуникации между изолированными агентами

Синхронизация (ECMA)
Atomics.wait() и Atomics.notify() - для агентов в рамках одного кластера.
Для обеспечения потокобезопасного доступа и синхронизации операций с  
SharedArrayBuffer используются атомарные операции, предоставляемые объектом Atomics.
Эти операции гарантируют, что чтение и запись в общую память происходят неделимо (атомарно), предотвращая состояния гонки. 

Atomics для синхронизации
// В Worker 1:
// Создаем SharedArrayBuffer и Int32Array для работы с ним
// 4 байта для одного Int32
const sharedBuffer = new SharedArrayBuffer(4); 
const sharedArray = new Int32Array(sharedBuffer);

// Записываем значение и уведомляем другой воркер
// Записываем 123 по индексу 0
Atomics.store(sharedArray, 0, 123); 
// Уведомляем один ожидающий поток по индексу 0
Atomics.notify(sharedArray, 0, 1); 
console.log('Worker 1: Value stored and notified.');
// В Worker 2:
// Получаем SharedArrayBuffer через postMessage от Worker 1
self.onmessage = function(e) {
  const sharedBuffer = e.data;
  const sharedArray = new Int32Array(sharedBuffer);

  console.log('Worker 2: Waiting for notification...');
  // Блокировка до уведомления от другого потока
  // Atomics.wait(sharedArray, index, expectedValue, timeout)
  // Здесь: ждем по индексу 0, если текущее значение 0.
  const status = Atomics.wait(sharedArray, 0, 0);
  console.log('Worker 2: Notification received. Status:', status);
  console.log('Worker 2: Value from shared memory:', sharedArray); // Выведет 123
};
Этот пример демонстрирует, как Atomics.wait() может блокировать поток до тех пор, пока другой поток не вызовет Atomics.notify(), обеспечивая координированный доступ к общей памяти.

Жизненный цикл (HTML)
- Агенты окна умирают с вкладкой
- Service Workers живут вне времени жизни страницы и могут переживать закрытие всех связанных с ними вкладок