Глава 2: Общая схема работы Event Loop

Описание высокоуровневой архитектуры Event Loop: 
Call Stack, Web/Node.js APIs и очереди

2.1. Стек вызовов (Call Stack)

Что это такое: 
Call Stack — это абстрактное представление Execution Context Stack, и фундаментальная структура данных, которая является частью JS-движка и отвечает за выполнение синхронного кода. 
Каждый вызов функции создаёт новый Execution Context("https://tc39.es/ecma262/#sec-execution-contexts"), который помещается на вершину стека по принципу LIFO

LIFO (Last In, First Out – последний пришел, первый вышел "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)"). 
Это означает, что функция, которая была вызвана последней, будет выполнена первой.

Как это работает: (cтек описан здесь "https://tc39.es/ecma262/#execution-context-stack")
-1 - Когда JS-движок начинает выполнять скрипт, он помещает глобальный контекст выполнения в Call Stack.
("Глобальный контекст исполнения - это базовый Execution Context, создающийся при запуске скрипта. Он содержит переменные и функции, объявленные в глобальной области видимости.")
-2 - При вызове функции, она "накладывается" (push) на вершину стека.
-3 - Код этой функции начинает выполняться. Если внутри этой функции вызываются другие функции, они также последовательно добавляются на вершину стека.
-4 - Когда функция завершает свое выполнение (возвращает значение или достигает конца), она "снимается" (pop) со стека.
-5 - Выполнение кода продолжается с того места, где остановилось в предыдущей функции, которая теперь находится на вершине стека.
-6 - Этот процесс продолжается до тех пор, пока Call Stack не станет пустым, что означает завершение выполнения всего синхронного JS кода.

"Run-to-Completion" (Выполнение до завершения):
(описан в спецификации как часть механизма исполнения Job Queue. "https://tc39.es/ecma262/#sec-jobs-and-job-queues")
Важной характеристикой Call Stack является принцип "выполнения до завершения". 
Это означает, что как только функция начинает выполняться в Call Stack, она будет выполнена полностью, прежде чем любая другая функция или задача сможет получить доступ к стеку. 
Принцип "выполнения до завершения" означает, что текущая выполняемая задача должна быть завершена полностью, прежде чем будет начата новая. Это — одно из следствий однопоточной природы JavaScript.
Если синхронная функция выполняет длительную операцию, она блокирует Call Stack, не позволяя Event Loop передавать другие задачи (обновление интерфейса или обработчики событий) в стек, что приводит к "зависанию" приложения.

Пример блокировки 
```
function block() {
  while (true) {} 
}
block(); 
```
=====================================================================================================================

2.2. Web/Node.js APIs 
(API среды выполнения)

Это набор интерфейсов и функций, предоставляемых средой. 
Эти API позволяют JS взаимодействовать с внешним миром и выполнять асинхронные операции, которые не могут быть обработаны непосредственно в Call Stack, чтобы не блокировать его.

Примеры Web APIs (в браузере):
- Таймеры: setTimeout(), setInterval().
- Сетевые запросы: fetch(), XMLHttpRequest.
- События DOM: addEventListener() (и проч).
- Работа с DOM: document.getElementById(), console.log() и проч.

Примеры Node.js APIs (на сервере):
- Файловая система: fs.readFile(), fs.writeFile().
- Сетевые операции: http.createServer(), net.connect().
- Таймеры: setTimeout(), setInterval(), setImmediate().

Как это работает

Когда JS-движок встречает асинхронную операцию (setTimeout или fetch), он не выполняет ее сам. 
Вместо этого он делегирует эту операцию соответствующему API среды выполнения. 
Эти API работают вне основного потока JS, часто используя собственные потоки или механизмы операционной системы для выполнения длительных задач. Это позволяет основному потоку JS оставаться свободным и продолжать выполнять другой код, не дожидаясь завершения асинхронной операции.

После того как асинхронная операция в Web/Node.js API завершается, связанная с ней функция обратного вызова (callback) помещается в соответствующую очередь (микро или макрозадач), откуда будет извлечена Event Loop'ом после завершения текущей синхронной задачи.

До того как продолжу дальше надо обьяснить ОООООчень важный момент
Это то как и что называется.

Главная проблема терминологии!

ECMAS и HTML используют разные термины для одних и тех же концепций, 
а разработчики добавили свои "народные" названия и тут понеслось.
(тут лично у меня когда я впервые в это влез получилась такая каша в голове из понятий что пиздец)

Но сейчас сейчас я уже вроде как шарю 
Так что разложу так чтоб остальные смогла избежать этой участи

ECMA-262 - Что говорит стандарт языка
Официальные термины из спецификации TC39:
- Job - отдельная единица работы
- Job Queue - очередь для выполнения Jobs
- PromiseJobs - конкретный тип Jobs для промисов
- EnqueueJob - операция добавления Job в очередь

Что попадает в Job Queue:
Promise.then(), Promise.catch(), Promise.finally()
queueMicrotask() - добавляет задачу в ту же очередь

Важно:
ECMA НЕ ИСПОЛЬЗУЕТ термины "microtask" или "macrotask" ВООБЩЕ!


WHATWG - Что говорит браузерная спецификация
Официальные термины из HTML spec:
- Task - единица работы в Event Loop
- Task Queue - очередь для Tasks
- Microtask - приоритетная задача
- Microtask Queue - очередь для Microtasks

Tasks (то что народ зовет "МАКРОЗАДАЧИ"):
- setTimeout(), setInterval()
- DOM события (click, load)
- Сетевые запросы (fetch)
- Выполнение <script>

Microtasks:
- Promise.then() (та же Job Queue из ECMAScript!)
- MutationObserver
- queueMicrotask()


"НАРОДНАЯ" терминология (я её дом шатал)
Разработчики для "удобства" придумали:

"Микрозадачи" (Microtasks)
-- Официально: ECMAScript Jobs / HTML Microtasks
-- Примеры: Promise callbacks, queueMicrotask()
-- Приоритет: Высокий

"Макрозадачи" (Macrotasks)
-- Официально: HTML Tasks
-- Примеры: setTimeout, DOM события, fetch
-- Приоритет: Низкий

ВАЖНО: Термин "macrotask" НЕ СУЩЕСТВУЕТ В ОФИЦИАЛЬНЫХ СПЕЦИФИКАЦИЯХ!

ЕЩЁ РАЗ ЧТОБ ТОЧНО ПОНЯТЬ 

Когда говоришь про спецификации:
- ECMA - "Job Queue для PromiseJobs"
- HTML - "Microtask Queue и Task Queue"

Когда объясняешь "разработчикам":
- Микрозадачи - (Promise.then)
- Макрозадачи - (setTimeout)
Микрозадачи - выполняются первыми, потом одна макрозадача

Порядок выполнения:
-1 - Синхронный код (Call Stack)
-2 - ВСЕ микрозадачи (Job Queue / Microtask Queue)
-3 - ОДНА макрозадача (Task из Task Queue)
-4 - Повторить с пункта 2

 Официальные ссылки

ECMAScript Jobs: https://tc39.es/ecma262/#sec-jobs-and-job-queues
HTML Tasks & Microtasks: https://html.spec.whatwg.org/multipage/webappapis.html#task-queue
Promise Jobs: https://tc39.es/ecma262/#sec-promise-resolve-functions
queueMicrotask: https://tc39.es/ecma262/#sec-queuemicrotask


А теперь когда разобрались, продолжу

Остановился я на :
"После того как асинхронная операция в Web/Node.js API завершается, связанная с ней функция обратного вызова (callback) помещается в соответствующую очередь (микро или макрозадач), откуда будет извлечена Event Loop'ом после завершения текущей синхронной задачи."

Очереди (Queues)

Существует две основные очереди, которые Event Loop использует для управления колбэками асинхронных операций.

1 - Очередь микрозадач 
(Microtask Queue)
Это очередь с высоким приоритетом. 
Она предназначена для задач, которые должны быть выполнены как можно скорее после завершения текущего синхронного кода. 
В спецификации ECMAS эта очередь называется Job Queue, а для промисов используется термин "PromiseJobs" (внутренний вид очереди).
Примеры:
- Колбэки промисов (.then(), .catch(), .finally()).
- Вызовы queueMicrotask().
- Колбэки MutationObserver API (для отслеживания изменений в DOM).
- process.nextTick() — это внутренняя очередь Node.js, не является частью стандарта ECMA или HTML. 
nextTickQueue обрабатывается СРАЗУ после завершения текущей JavaScript операции.
(даже до обработки microtask queue), независимо от фазы Event Loop.

2- Очередь обратных вызовов / Очередь макрозадач 
(Callback Queue / Macrotask Queue / Task Queue)
Это очередь с более низким приоритетом для асинхронных задач. Она работает по принципу FIFO (First In, First Out).
Хочу отметить, что в стандарте HTML(WHATWG) эти задачи называются просто "tasks"(задачи). 
Термин "macrotask" широко используется в сообществе разработчиков как антоним к "microtask" для подчеркивания их различий в приоритете, но не является формальным термином спецификации HTML.
Примеры:
- Таймеры, setTimeout() и setInterval().
- Операции ввода/вывода (I/O), сетевые запросы (fetch, XMLHttpRequest) и операции с файловой системой (в Node.js).
- События DOM (click, load).
- Выполнение скриптов <script>.
- setImmediate() в Node.js: выполняется в фазе check Event Loop, после фазы poll (I/O).


Event Loop (Оркестратор/Дерижёр)
Это бесконечный цикл, который постоянно проверяет состояние Call Stack и очередей, чтобы определить, какие задачи должны быть выполнены следующими.

Алгоритм работы Event Loop (без задротства):
-1 - Выполнение синхронного кода: JavaScript-движок сначала выполняет весь синхронный код, который находится в Call Stack.
-2 - Проверка Call Stack: Event Loop постоянно проверяет, пуст ли Call Stack.
-3 - Опустошение очереди микрозадач: Если Call Stack пуст, Event Loop первым делом полностью опустошает очередь микрозадач. Если во время выполнения микрозадачи в очередь добавляются новые микрозадачи, они также будут выполнены в рамках текущей итерации Event Loop, прежде чем будет обработана следующая макрозадача.
-4 - Рендеринг (в браузере): После опустошения очереди микрозадач, браузер МОЖЕТ ВЫБРАТЬ 
выполнить обновление рендеринга, но это НЕ ПРОИСХОДИТ в каждой итерации Event Loop. 
Решение принимается на основе requestAnimationFrame, изменений DOM и других факторов.
-5 - Выбор и выполнение одной макрозадачи: Только после того, как Call Stack и очередь микрозадач полностью опустели, Event Loop выбирает одну (самую старую) макрозадачу из очереди макрозадач и помещает ее колбэк в Call Stack для выполнения.
-6 - Повторение: После выполнения этой макрозадачи цикл повторяется, начиная с шага 1: Event Loop снова проверяет Call Stack, затем очередь микрозадач, затем, возможно, выполняет рендеринг, и только потом переходит к следующей макрозадаче.

Важно для Node.js:
Event Loop в Node.js имеет несколько фаз (timer, pending callbacks, poll, check, close callbacks).
setImmediate() выполняется в фазе "check", а setTimeout() в фазе "timer".
Поэтому порядок setImmediate() и setTimeout(0) может отличаться в зависимости от контекста!

Пример
(который так любят спрашивать не понимая сути)
```
// 1. Синхронный код
console.log('Start'); 

setTimeout(() => {
  // 4. Макрозадача
  console.log('setTimeout Callback'); 
}, 0);

Promise.resolve().then(() => {
  // 3. Микрозадача
  console.log('Promise Resolved'); 
});

// 2. Синхронный код
console.log('End'); 
```
Порядок вывода:
- Start (Синхронный код).
- End (Синхронный код).
- Promise Resolved (Микрозадача).
- setTimeout Callback (Макрозадача).

Это происходит потому, что синхронный код выполняется первым. 
Затем Event Loop опустошает очередь микрозадач, и только после этого переходит к очереди макрозадач.

Дополнение к примеру для Node.js
```
// В Node.js порядок будет отличаться:
console.log('Start');

setTimeout(() => {
  console.log('setTimeout Callback'); // 5. Макрозадача
}, 0);

Promise.resolve().then(() => {
  console.log('Promise Resolved'); // 4. Микрозадача (Promise)
});

process.nextTick(() => {
  console.log('nextTick Callback'); // 3. nextTick (приоритетнее микрозадач!)
});

console.log('End'); // 2. Синхронный код

// Вывод в Node.js:
// Start
// End  
// nextTick Callback  ← выполняется ДО Promise!
// Promise Resolved
// setTimeout Callback
```

Игого
Event Loop, Call Stack, Web/Node.js APIs и очереди работают в тесной связке, обеспечивая неблокирующее и эффективное выполнение JS кода, создавая иллюзию параллелизма, хотя сам JS-движок обрабатывает код в одном потоке.

Поэтому корректнее говорить:
- JS ENGINE (V8, SpiderMonkey) - однопоточный
- JS RUNTIME (браузер, Node.js) - использует многопоточность для Web APIs
- Event Loop создает иллюзию параллелизма в однопоточной среде выполнения кода

JS как язык выполняется в одном потоке, но runtime обеспечивает 
неблокирующее выполнение через многопоточные Web APIs.

Ну или на костёр меня ;)